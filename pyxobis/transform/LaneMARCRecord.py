#!/usr/bin/python3
# -*- coding: UTF-8 -*-

"""
Superclass of pymarc Record for LaneMARC/XOBIS-specific tasks.
"""

import regex as re
from pymarc import Record
from .tf_common import *

class LaneMARCRecord(Record):
    # carry element type constants into class scope for outside access
    # WORK_AUT     = WORK_AUT
    # WORK_INST    = WORK_INST
    # BEING        = BEING
    # CONCEPT      = CONCEPT
    # EVENT        = EVENT
    # LANGUAGE     = LANGUAGE
    # OBJECT       = OBJECT
    # ORGANIZATION = ORGANIZATION
    # PLACE        = PLACE
    # TIME         = TIME
    # STRING       = STRING
    # RELATIONSHIP = RELATIONSHIP
    # HOLDINGS     = HOLDINGS

    def get_control_number(self):
        # Record control number (001 plus prefix letter; generated by RIM in 035 ^9)
        record_control_nos = self.get_subfields('035','9')
        if record_control_nos:
            return record_control_nos[0]
        elif '852' in self:
            # Holdings don't currently have them; build from 001 instead
            return 'H' + self['001'].data
        # TEMPORARY: PASS ANY RECORD THAT DOESN'T HAVE 035 9 INSERTED
        return None

    def get_primary_categories(self):
        return [val for field in self.get_fields('655') for val in field.get_subfields('a') if field.indicator1 == '1']

    def get_broad_category(self):
        # returns 655 47 ^a if record has exactly one, otherwise prints warning
        broad_categories = [field['a'] for field in self.get_fields('655') if field.indicator1 == '4']
        if not broad_categories:
            print("WARNING: record {} has no broad category (655 47)".format(self['001'].data))
            broad_categories.append(None)
        elif len(broad_categories) > 1:
            print("WARNING: record {} has more than one broad category (655 47)".format(self['001'].data))
        return broad_categories[0]

    def get_subsets(self):
        return [val for field in self.get_fields('655') for val in field.get_subfields('a') if field.indicator1 in '78']

    def get_all_categories(self):
        return [val for field in self.get_fields('655') for val in field.get_subfields('a') if field.indicator1 not in '78']

    def get_xobis_element_type(self):
        """
        Returns a 3-letter code representing the record's type in XOBIS.
        """
        if 'Suppressed' in self.get_subsets():
            return None
        # ~~~~~~ BIB ~~~~~~
        if '245' in self:
            return OBJECT if self.get_broad_category() in ['Objects'] else WORK_INST
        # ~~~~~~ AUT ~~~~~~
        elif '100' in self: return BEING
        elif '110' in self: return ORGANIZATION
        elif '111' in self: return EVENT
        elif '130' in self: return WORK_AUT
        elif '150' in self:
            broad_category = self.get_broad_category()
            if broad_category in ['Languages','Scripts']:
                return LANGUAGE
            elif broad_category in ['Times']:
                return TIME
            else:
                return CONCEPT
        elif '151' in self: return PLACE
        elif '155' in self:
            broad_category = self.get_broad_category()
            if 'Relationship' in broad_category:
                return 'rel'
            elif broad_category in ['Record Type','Subset','Relationship Type']:
                return CONCEPT
            elif broad_category in ['Category']:
                if 'Restricted Usage' in self.get_subfields('655','a'):
                    return CONCEPT
                else:
                    return None
        elif '180' in self: return CONCEPT
        elif '182' in self: return STRING
        # ~~~~~~ HDG ~~~~~~
        elif '852' in self: return HOLDINGS
        else:
            return None

    def get_id_field(self):
        """
        Returns field containing the identity.
        """
        for tag in ('149','100','110','111','130','150','151','155','180','182'):
            if tag in self:
                return self[tag]
        return None

    def get_identity(self):
        """
        Returns control number, XOBIS element type, and identity string for this record as a whole.
        """
        if 'Suppressed' in self.get_subsets():
            return (), None, None
        ctrlno = self.get_control_number()
        # @@@@ TEMPORARY? IS AN "IDENTITY" NECESSARY FOR HOLDINGS? @@@@
        if ctrlno is None or ctrlno.startswith('H'):
            return (), None, None
        # which 1xx field contains the identity?
        id_field = self.get_id_field()
        if id_field is None:
            print("PROBLEM: no id found:", ctrlno)
            return (), None, None
        # get the identity
        element_type = self.get_xobis_element_type()
        identity = self.get_field_identity(id_field, element_type)
        return ctrlno, element_type, identity

    IDENTITY_SUBFIELD_MAP = { WORK_INST:    'adhklnpqs',   # 149
                              WORK_AUT:     'adfghklnpqs', # 130
                              BEING:        'abcdq',       # 100
                              ORGANIZATION: 'abcdn',       # 110
                              EVENT:        'acden',       # 111
                              OBJECT:       'adhklnpqs',   # 149
                              CONCEPT:      'ax',          # 150/155/180
                              TIME:         'a',           # 150
                              LANGUAGE:     'a',           # 150
                              PLACE:        'az',          # 151
                              RELATIONSHIP: 'a',           # 155
                              STRING:       'yqg3' }       # 182

    def is_referential(self):
        if '008' not in self:
            return None
        return self['008'].data[9] in 'bce' or 'Unestablished' in self.get_subsets()

    @classmethod
    def get_field_identity(cls, field, element_type):
        """
        Generates identity string from given pymarc field and XOBIS type.
        """
        # which subfields should be included as part of the identity?
        if element_type not in cls.IDENTITY_SUBFIELD_MAP:
            return None
        subfields = cls.IDENTITY_SUBFIELD_MAP[element_type]
        # pull and normalize those subfields to generate the identity
        identity = []
        for code in subfields:
            if code in field:
                for value in field.get_subfields(code):
                    identity.append(code)
                    identity.append(cls.normalize(value))
            else:
                identity.append(code)
                identity.append('')
        if not identity:
            return None
        return ','.join(identity)

    @classmethod
    def normalize(cls, text):
        """
        Normalization algorithm for indexing:
        1. Convert anything of Unicode General Category
           Punctuation (P*), Separator (Z*), or Other (C*)
           to single spaces.
           (Requires the `regex` module, `re` cannot use \p)
        2. Strip.
        3. Convert to lowercase.
        """
        return re.sub(r"[\p{P}\p{Z}\p{C}]+", ' ', text).strip().lower()
